package test.fast.extractValidations;

import com.fasterxml.jackson.databind.JsonNode;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.nyl.base.Constants;
import com.nyl.base.WebBase;
import com.nyl.printpolicy.excel.ExcelToMap;
import com.nyl.utilities.FASTSystemLibrary;
import com.relevantcodes.extentreports.ExtentReports;
import com.relevantcodes.extentreports.ExtentTest;
import com.relevantcodes.extentreports.LogStatus;
import org.apache.poi.ss.usermodel.*;
import org.apache.poi.xssf.usermodel.XSSFWorkbook;
import org.apache.poi.ss.usermodel.DateUtil;
import org.testng.annotations.AfterClass;
import org.testng.annotations.BeforeClass;
import org.testng.annotations.Parameters;
import org.testng.annotations.Test;

import java.io.File;
import java.io.FileInputStream;
import java.io.IOException;
import java.text.SimpleDateFormat;
import java.util.Date;
import java.util.HashMap;
import java.util.Map;

public class PrintPolicyValidation extends WebBase {

    @BeforeClass
    public void reportInitialize() {
        testResultsFolderPath = Constants.EXTRACTS_REPORTS_FOLDER_PATH;
        testReportName = "PrintPolicy";
        considerBlankValue = true;
        setupTestsAndReport();
    }

    @Parameters({"jsonFilePath", "excelFilePath", "mappingFilePath"})
    @Test
    public void validatePrintPolicyExtract(String jsonFilePath, String excelFilePath, String mappingFilePath) throws IOException {
        // Load JSON data
        ObjectMapper objectMapper = new ObjectMapper();
        JsonNode rootNode = objectMapper.readTree(new File(jsonFilePath));

        // Load Excel workbook
        Workbook workbook = new XSSFWorkbook(new FileInputStream(excelFilePath));

        // Read mappings and value mappings
        Workbook mappingWorkbook = new XSSFWorkbook(new FileInputStream(mappingFilePath));
        Map<String, String> jsonToExcelMapping = readMappingFromExcel(mappingWorkbook);
        Map<String, Map<String, String>> ExcelValueMapping = readValueMappingFromExcel(mappingWorkbook);

        // Extract policy number from JSON
        String policyNumberJson = extractPolicyNumberFromJson(rootNode);

        if (policyNumberJson == null) {
            System.out.println("Policy number not found in JSON.");
            return;
        }

        // Check if policy number exists in Excel
        if (!checkPolicyNumberInExcel(workbook, policyNumberJson)) {
            System.out.println("Policy number not found in Excel.");
            return;
        }

        // Extract data and perform validation
        Map<String, String> jsonData = extractDataFromJson(rootNode, jsonToExcelMapping);
        Map<String, Map<String, String>> excelData = ExcelToMap.returnData(policyNumberJson);

        compareData(jsonData, excelData, jsonToExcelMapping, policyNumberJson, ExcelValueMapping);

        // Close resources
        workbook.close();
        mappingWorkbook.close();
    }

    public static Map<String, String> readMappingFromExcel(Workbook workbook) {
        Map<String, String> mapping = new HashMap<>();
        Sheet sheet = workbook.getSheet("Sheet1");

        for (Row row : sheet) {
            if (row.getRowNum() == 0) continue; // Skip header row
            String jsonKey = getStringValue(row.getCell(0));
            String excelKey = getStringValue(row.getCell(1));
            mapping.put(jsonKey, excelKey);
        }

        return mapping;
    }

    public static Map<String, Map<String, String>> readValueMappingFromExcel(Workbook workbook) {
        Map<String, Map<String, String>> valueMapping = new HashMap<>();
        Sheet sheet = workbook.getSheet("ValueMapping");

        if (sheet == null) {
            throw new RuntimeException("ValueMapping sheet is missing in the provided workbook.");
        }

        for (Row row : sheet) {
            if (row.getRowNum() == 0) continue; // Skip header row
            String excelKey = getStringValue(row.getCell(0));
            String actualValue = getStringValue(row.getCell(1));
            String expectedValue = getStringValue(row.getCell(2));

            Map<String, String> values = new HashMap<>();
            values.put("actual", actualValue);
            values.put("expected", expectedValue);
            valueMapping.put(excelKey, values);
        }

        return valueMapping;
    }

    public static String extractPolicyNumberFromJson(JsonNode rootNode) {
        String jsonKeyForPolicyNumber = "policyDetail.policySpecification.policyNumber";
        JsonNode policyNumberNode = rootNode.at("/" + jsonKeyForPolicyNumber.replace(".", "/"));
        return policyNumberNode.isMissingNode() ? null : policyNumberNode.asText();
    }

    public static boolean checkPolicyNumberInExcel(Workbook workbook, String policyNumber) {
        Sheet sheet = workbook.getSheetAt(0);
        for (int i = 4; i <= sheet.getLastRowNum(); i++) {
            Row row = sheet.getRow(i);
            String policyNm = ExcelToMap.getCellValueAsString(row.getCell(2));
            if (policyNumber.equals(policyNm)) {
                return true;
            }
        }
        return false;
    }

    public static Map<String, String> extractDataFromJson(JsonNode rootNode, Map<String, String> mapping) {
        Map<String, String> jsonData = new HashMap<>();
        for (String jsonKey : mapping.keySet()) {
            String value = getJsonValue(rootNode, jsonKey);
            jsonData.put(jsonKey, value);
        }
        return jsonData;
    }

    public static String getJsonValue(JsonNode rootNode, String jsonPath) {
        JsonNode currentNode = rootNode;
        for (String key : jsonPath.split("\\.")) {
            currentNode = currentNode.path(key);
            if (currentNode.isMissingNode()) return null;
        }
        return currentNode.asText();
    }

    public void compareData(
            Map<String, String> jsonData, 
            Map<String, Map<String, String>> excelData, 
            Map<String, String> jsonToExcelMapping, 
            String policyNumberJson, 
            Map<String, Map<String, String>> ExcelValueMapping) {

        ExtentReports tempReport = new ExtentReports("printpolicyvalidations.html");
        ExtentTest extractTest = tempReport.startTest("Validation Results for Policy - " + policyNumberJson);
        ExtentTest subTest = tempReport.startTest("Validate Print Policy Extract Fields in TRAD File");

        for (String key : jsonData.keySet()) {
            String jsonValue = jsonData.get(key);
            String excelKey = jsonToExcelMapping.get(key);
            if (excelKey == null) {
                subTest.log(LogStatus.WARNING, "No mapping found for JSON key: " + key);
                continue;
            }

            String[] parts = excelKey.split("\\.");
            String excelSheet = parts[0];
            String excelField = parts[1];
            String excelValue = excelData.get(excelSheet).get(excelField);

            if (ExcelValueMapping.containsKey(excelKey)) {
                Map<String, String> mapping = ExcelValueMapping.get(excelKey);
                if (excelValue.equals(mapping.get("actual"))) {
                    excelValue = mapping.get("expected");
                }
            }

            if (!jsonValue.equals(excelValue)) {
                subTest.log(LogStatus.FAIL, excelField + " not matched - PP Extract Value : [" + jsonValue + "], TRAD Value : [" + excelValue + "]");
            } else {
                subTest.log(LogStatus.PASS, excelField + " matched - PP Extract Value : [" + jsonValue + "], TRAD Value : [" + excelValue + "]");
            }
        }

        extractTest.appendChild(subTest);
        tempReport.flush();
    }

    public static String getStringValue(Cell cell) {
        if (cell == null) return "";
        switch (cell.getCellType()) {
            case STRING:
                return cell.getStringCellValue();
            case NUMERIC:
                return DateUtil.isCellDateFormatted(cell) 
                        ? new SimpleDateFormat("MM/dd/yyyy").format(cell.getDateCellValue()) 
                        : String.valueOf((int) cell.getNumericCellValue());
            default:
                return "";
        }
    }

    @AfterClass
    public void reportFlush() {
        mainReport.flush();
    }
}
